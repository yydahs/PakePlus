<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šé¡¹ç›®è®°è´¦å·¥å…·</title>
    
    <!-- Element Plus CSS -->
    <link href="./static/index.css" rel="stylesheet">
    
    <!-- Vue 3 -->
    <script src="./static/vue.global.js"></script>
    
    <!-- Element Plus JS -->
    <script src="./static/index.full.js"></script>
    
    <!-- Element Plus ä¸­æ–‡è¯­è¨€åŒ… -->
    <script src="./static/zh-cn.min.js"></script>
    
    <!-- Excelå¯¼å‡ºåº“ -->
    <script src="./static/xlsx.full.min.js"></script>
    
    <!-- æ—¥æœŸå¤„ç†åº“ -->
    <script src="./static/dayjs.min.js"></script>
    
    <!-- å›¾è¡¨åº“ -->
    <script src="./static/chart.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .main-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            min-height: 600px;
        }
        
        .project-selector {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .stats-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        
        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .income { color: #27AE60; }
        .expense { color: #E74C3C; }
        .balance { color: #3498DB; }
        .count { color: #9B59B6; }
        
        .filters {
            display: grid;
            /* grid-template-columns: 150px 150px auto 230px 150px 150px; */
            /* æœç´¢æ å®½åº¦ */
            grid-template-columns: auto auto auto auto auto auto;
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            align-items: center;
        }
        
        .table-container {
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .charts-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-top: 30px;
        }
        
        .chart-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            border: 1px solid #e9ecef;
        }
        
        @media (max-width: 768px) {
            .filters {
                grid-template-columns: 1fr;
            }
            .charts-section {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="container">
            <!-- é¡µé¢å¤´éƒ¨ -->
            <div class="header">
                <h1>ğŸ’° è®°è´¦å·¥å…·</h1>
                <p>é¡¹ç›®åŒ–ç®¡ç†æ‚¨çš„æ”¶æ”¯ï¼Œæ•°æ®æœ¬åœ°å­˜å‚¨æ›´å®‰å…¨</p>
            </div>

            <div class="main-content">
                <!-- é¡¹ç›®é€‰æ‹©å™¨ -->
                <div class="project-selector">
                    <el-select v-model="currentProject" placeholder="é€‰æ‹©é¡¹ç›®" style="width: 200px" @change="onProjectChange">
                        <el-option 
                            v-for="project in projects" 
                            :key="project.id" 
                            :label="project.name" 
                            :value="project.id">
                        </el-option>
                    </el-select>
                    <el-button type="primary" @click="showProjectDialog = true">æ–°å»ºé¡¹ç›®</el-button>
                    <el-button type="warning" @click="editCurrentProject" :disabled="!currentProject">ç¼–è¾‘é¡¹ç›®</el-button>
                    <el-button type="danger" @click="deleteCurrentProject" :disabled="!currentProject">åˆ é™¤é¡¹ç›®</el-button>
                </div>

                <!-- å½“å‰é¡¹ç›®ä¿¡æ¯ -->
                <div v-if="currentProjectData">
                    <!-- <h3>{{ currentProjectData.name }}</h3>
                    <p style="color: #666; margin-bottom: 20px;">{{ currentProjectData.description }}</p> -->
                    
                    <!-- ç»Ÿè®¡å¡ç‰‡ -->
                    <div class="stats-cards">
                        <div class="stat-card">
                            <div>ğŸ’° æ€»æ”¶å…¥</div>
                            <div class="stat-value income">Â¥{{ formatMoney(totalIncome) }}</div>
                            <small>{{ incomeCount }}ç¬”æ”¶å…¥</small>
                        </div>
                        <div class="stat-card">
                            <div>ğŸ’¸ æ€»æ”¯å‡º</div>
                            <div class="stat-value expense">Â¥{{ formatMoney(totalExpense) }}</div>
                            <small>{{ expenseCount }}ç¬”æ”¯å‡º</small>
                        </div>
                        <div class="stat-card">
                            <div>ğŸ’³ æ”¶æ”¯å·®é¢ï¼ˆæ”¶å…¥-æ”¯å‡ºï¼‰</div>
                            <div class="stat-value" :class="{ 'income': balance >= 0, 'expense': balance < 0 }">
                                {{ balance >= 0 ? '+' : '-' }}Â¥{{ formatMoney(Math.abs(balance)) }}
                            </div>
                            <small>{{ balance >= 0 ? 'ç›ˆä½™' : 'èµ¤å­—' }}</small>
                        </div>
                        <div class="stat-card">
                            <div>ğŸ“Š è®°å½•æ€»æ•°</div>
                            <div class="stat-value count">{{ totalRecords }}</div>
                            <small>ç¬”è´¢åŠ¡è®°å½•</small>
                        </div>
                    </div>

                    <!-- æ“ä½œæŒ‰é’® -->
                    <div style="margin-bottom: 20px;">
                        <el-button type="primary" @click="showRecordDialog = true">æ–°å¢è®°å½•</el-button>
                        <el-button type="success" @click="showTypeDialog = true">ç®¡ç†ç±»å‹</el-button>
                        <el-button type="info" @click="exportData">å¯¼å‡ºExcel</el-button>
                        <el-button type="warning" @click="showImportDialog = true" :disabled="!canImport">å¯¼å…¥Excel</el-button>
                    </div>

                    <!-- ç­›é€‰å™¨ -->
                    <div class="filters">
                        <el-select v-model="filters.type" placeholder="é€‰æ‹©ç±»å‹" clearable>
                            <el-option label="å…¨éƒ¨ç±»å‹" value=""></el-option>
                            <el-option v-for="type in currentProjectTypes" :key="type" :label="type" :value="type"></el-option>
                        </el-select>
                        
                        <el-select v-model="filters.category" placeholder="æ”¶æ”¯ç±»åˆ«" clearable>
                            <el-option label="å…¨éƒ¨ç±»åˆ«" value=""></el-option>
                            <el-option label="æ”¶å…¥" value="income"></el-option>
                            <el-option label="æ”¯å‡º" value="expense"></el-option>
                        </el-select>
                        
                        <el-date-picker
                            v-model="filters.dateRange"
                            type="daterange"
                            range-separator="è‡³"
                            start-placeholder="å¼€å§‹æ—¥æœŸ"
                            end-placeholder="ç»“æŸæ—¥æœŸ"
                            format="YYYY-MM-DD"
                            value-format="YYYY-MM-DD">
                        </el-date-picker>
                        
                        <el-input v-model="filters.keyword" placeholder="æœç´¢å¤‡æ³¨" clearable></el-input>
                        
                        <el-button type="primary" @click="applyFilters">ç­›é€‰</el-button>
                        <el-button @click="resetFilters">é‡ç½®</el-button>
                    </div>

                    <!-- æ•°æ®è¡¨æ ¼ -->
                    <div class="table-container">
                        <el-table :data="paginatedData" style="width: 100%" stripe border>
                            <el-table-column prop="date" label="æ—¥æœŸ" width="130" sortable>
                                <template #default="{ row }">
                                    {{ formatDate(row.date) }}
                                </template>
                            </el-table-column>
                            <el-table-column prop="type" label="ç±»å‹" width="140">
                                <template #default="{ row }">
                                    <el-tag size="small" :type="getTypeTagColor(row.type)">{{ row.type }}</el-tag>
                                </template>
                            </el-table-column>
                            <el-table-column prop="category" label="ç±»åˆ«" width="110">
                                <template #default="{ row }">
                                    <el-tag :type="row.category === 'income' ? 'success' : 'danger'" size="small">
                                        {{ row.category === 'income' ? 'æ”¶å…¥' : 'æ”¯å‡º' }}
                                    </el-tag>
                                </template>
                            </el-table-column>
                            <el-table-column prop="amount" label="é‡‘é¢" width="160" sortable>
                                <template #default="{ row }">
                                    <span :class="{ 'income': row.category === 'income', 'expense': row.category === 'expense' }" style="font-weight: bold;">
                                        {{ row.category === 'income' ? '+' : '-' }}Â¥{{ formatMoney(row.amount) }}
                                    </span>
                                </template>
                            </el-table-column>
                            <el-table-column prop="remark" label="å¤‡æ³¨" min-width="150"></el-table-column>
                            <el-table-column prop="ticketLocation" label="ç¥¨æ®ä½ç½®" min-width="120"></el-table-column>
                            <el-table-column label="æ“ä½œ" width="160">
                                <template #default="{ row }">
                                    <el-button type="primary" size="small" @click="editRecord(row)">ç¼–è¾‘</el-button>
                                    <el-button type="danger" size="small" @click="deleteRecord(row.id)">åˆ é™¤</el-button>
                                </template>
                            </el-table-column>
                        </el-table>
                    </div>

                    <!-- åˆ†é¡µ -->
                    <div style="display: flex; justify-content: center; margin-top: 20px;">
                        <el-pagination
                            v-model:current-page="currentPage"
                            v-model:page-size="pageSize"
                            :page-sizes="[10, 20, 50, 100]"
                            layout="total, sizes, prev, pager, next, jumper"
                            :total="filteredData.length"
                            background>
                        </el-pagination>
                    </div>

                    <!-- å›¾è¡¨åˆ†æ -->
                    <div v-if="filteredData.length > 0" class="charts-section">
                        <div class="chart-card">
                            <h4 style="text-align: center; margin-bottom: 20px;">ğŸ“ˆ æœˆåº¦æ”¶æ”¯è¶‹åŠ¿</h4>
                            <canvas ref="trendChart" style="max-height: 300px;"></canvas>
                        </div>
                        
                        <div class="chart-card">
                            <h4 style="text-align: center; margin-bottom: 20px;">ğŸ¥§ æ”¯å‡ºç±»å‹åˆ†å¸ƒ</h4>
                            <canvas ref="categoryChart" style="max-height: 300px;"></canvas>
                        </div>
                    </div>
                </div>

                <!-- æ— é¡¹ç›®æç¤º -->
                <div v-else style="text-align: center; padding: 60px 20px; color: #666;">
                    <div style="font-size: 4em; margin-bottom: 20px;">ğŸ“Š</div>
                    <h3>æ¬¢è¿ä½¿ç”¨å¤šé¡¹ç›®è®°è´¦å·¥å…·</h3>
                    <p>è¯·å…ˆåˆ›å»ºä¸€ä¸ªé¡¹ç›®å¼€å§‹è®°è´¦</p>
                    <el-button type="primary" @click="showProjectDialog = true">åˆ›å»ºç¬¬ä¸€ä¸ªé¡¹ç›®</el-button>
                </div>
            </div>
        </div>

        <!-- é¡¹ç›®å¯¹è¯æ¡† -->
        <el-dialog v-model="showProjectDialog" :title="editingProject ? 'ç¼–è¾‘é¡¹ç›®' : 'æ–°å»ºé¡¹ç›®'" width="500px">
            <el-form :model="projectForm" label-width="80px">
                <el-form-item label="é¡¹ç›®åç§°" required>
                    <el-input v-model="projectForm.name" placeholder="è¯·è¾“å…¥é¡¹ç›®åç§°"></el-input>
                </el-form-item>
                <el-form-item label="é¡¹ç›®æè¿°">
                    <el-input v-model="projectForm.description" type="textarea" placeholder="è¯·è¾“å…¥é¡¹ç›®æè¿°"></el-input>
                </el-form-item>
            </el-form>
            <template #footer>
                <el-button @click="showProjectDialog = false">å–æ¶ˆ</el-button>
                <el-button type="primary" @click="saveProject">ä¿å­˜</el-button>
            </template>
        </el-dialog>

        <!-- è®°å½•å¯¹è¯æ¡† -->
        <el-dialog v-model="showRecordDialog" :title="editingRecord ? 'ç¼–è¾‘è®°å½•' : 'æ–°å¢è®°å½•'" width="500px">
            <el-form :model="recordForm" label-width="80px">
                <el-form-item label="ç±»å‹" required>
                    <el-select v-model="recordForm.type" placeholder="é€‰æ‹©ç±»å‹" style="width: 100%">
                        <el-option v-for="type in currentProjectTypes" :key="type" :label="type" :value="type"></el-option>
                    </el-select>
                </el-form-item>
                <el-form-item label="ç±»åˆ«" required>
                    <el-radio-group v-model="recordForm.category">
                        <el-radio label="income">æ”¶å…¥</el-radio>
                        <el-radio label="expense">æ”¯å‡º</el-radio>
                    </el-radio-group>
                </el-form-item>
                <el-form-item label="é‡‘é¢" required>
                    <el-input-number v-model="recordForm.amount" :min="0" :precision="2" style="width: 100%"></el-input-number>
                </el-form-item>
                <el-form-item label="æ—¥æœŸ" required>
                    <el-date-picker v-model="recordForm.date" type="date" format="YYYY-MM-DD" value-format="YYYY-MM-DD" style="width: 100%"></el-date-picker>
                </el-form-item>
                <el-form-item label="å¤‡æ³¨">
                    <el-input v-model="recordForm.remark" type="textarea" placeholder="è¯·è¾“å…¥å¤‡æ³¨"></el-input>
                </el-form-item>
                <el-form-item label="ç¥¨æ®ä½ç½®">
                    <el-input v-model="recordForm.ticketLocation" placeholder="è¯·è¾“å…¥ç¥¨æ®ä½ç½®"></el-input>
                </el-form-item>
            </el-form>
            <template #footer>
                <el-button @click="showRecordDialog = false">å–æ¶ˆ</el-button>
                <el-button type="primary" @click="saveRecord">ä¿å­˜</el-button>
            </template>
        </el-dialog>

        <!-- ç±»å‹ç®¡ç†å¯¹è¯æ¡† -->
        <el-dialog v-model="showTypeDialog" title="ç®¡ç†ç±»å‹" width="400px">
            <div style="margin-bottom: 20px;">
                <el-input v-model="newTypeName" placeholder="è¾“å…¥æ–°ç±»å‹åç§°" style="width: 250px; margin-right: 10px;"></el-input>
                <el-button type="primary" @click="addType">æ·»åŠ </el-button>
            </div>
            <el-tag v-for="type in currentProjectTypes" :key="type" closable @close="removeType(type)" style="margin: 5px;">
                {{ type }}
            </el-tag>
        </el-dialog>

        <!-- å¯¼å…¥Excelå¯¹è¯æ¡† -->
        <el-dialog v-model="showImportDialog" title="å¯¼å…¥Excelæ•°æ®" width="500px">
            <div style="margin-bottom: 20px;">
                <el-alert 
                    title="å¯¼å…¥è¯´æ˜" 
                    type="info" 
                    :closable="false" 
                    style="margin-bottom: 15px;">
                    <template #default>
                        <div>â€¢ åªèƒ½å¯¼å…¥æœ¬ç³»ç»Ÿå¯¼å‡ºçš„Excelæ–‡ä»¶</div>
                        <div>â€¢ é¡¹ç›®å¿…é¡»æ²¡æœ‰ä»»ä½•è®°å½•æ‰èƒ½å¯¼å…¥</div>
                        <div>â€¢ å¯¼å…¥æˆåŠŸåï¼Œæ­¤é¡¹ç›®å°†ä¸èƒ½å†æ¬¡å¯¼å…¥</div>
                        <div>â€¢ æ”¯æŒåŒ…å«"æ”¶å…¥è®°å½•"å’Œ"æ”¯å‡ºè®°å½•"å·¥ä½œè¡¨çš„æ–‡ä»¶</div>
                    </template>
                </el-alert>
                
                <el-upload
                    ref="uploadRef"
                    :auto-upload="false"
                    :show-file-list="true"
                    :limit="1"
                    accept=".xlsx,.xls"
                    :on-change="handleFileChange"
                    :before-remove="handleFileRemove">
                    <el-button type="primary">é€‰æ‹©Excelæ–‡ä»¶</el-button>
                    <template #tip>
                        <div style="color: #666; font-size: 12px; margin-top: 5px;">
                            åªèƒ½ä¸Šä¼  .xlsx æˆ– .xls æ ¼å¼çš„æ–‡ä»¶
                        </div>
                    </template>
                </el-upload>
            </div>
            
            <div v-if="importPreviewData.length > 0" style="margin-bottom: 20px;">
                <h4>æ•°æ®é¢„è§ˆï¼ˆå‰5æ¡è®°å½•ï¼‰ï¼š</h4>
                <el-table :data="importPreviewData.slice(0, 5)" size="small" border>
                    <el-table-column prop="date" label="æ—¥æœŸ" width="100"></el-table-column>
                    <el-table-column prop="type" label="ç±»å‹" width="100"></el-table-column>
                    <el-table-column prop="category" label="ç±»åˆ«" width="80">
                        <template #default="{ row }">
                            {{ row.category === 'income' ? 'æ”¶å…¥' : 'æ”¯å‡º' }}
                        </template>
                    </el-table-column>
                    <el-table-column prop="amount" label="é‡‘é¢" width="100"></el-table-column>
                    <el-table-column prop="remark" label="å¤‡æ³¨" show-overflow-tooltip></el-table-column>
                </el-table>
                <div style="margin-top: 10px; color: #666; font-size: 14px;">
                    é¢„è®¡å¯¼å…¥ {{ totalImportCount }} æ¡è®°å½•
                </div>
            </div>

            <template #footer>
                <el-button @click="cancelImport">å–æ¶ˆ</el-button>
                <el-button 
                    type="primary" 
                    @click="confirmImport" 
                    :disabled="importPreviewData.length === 0"
                    :loading="importLoading">
                    ç¡®è®¤å¯¼å…¥
                </el-button>
            </template>
        </el-dialog>
    </div>

    <script>
        const { createApp } = Vue;
        const { ElMessage, ElMessageBox } = ElementPlus;

        // IndexedDB ç®¡ç†ç±»
        class AccountingDB {
            constructor() {
                this.dbName = 'AccountingDB';
                this.version = 1;
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // é¡¹ç›®è¡¨
                        if (!db.objectStoreNames.contains('projects')) {
                            const projectStore = db.createObjectStore('projects', { keyPath: 'id', autoIncrement: true });
                            projectStore.createIndex('name', 'name', { unique: false });
                        }
                        
                        // è®°å½•è¡¨
                        if (!db.objectStoreNames.contains('records')) {
                            const recordStore = db.createObjectStore('records', { keyPath: 'id', autoIncrement: true });
                            recordStore.createIndex('projectId', 'projectId', { unique: false });
                            recordStore.createIndex('date', 'date', { unique: false });
                        }
                        
                        // ç±»å‹è¡¨
                        if (!db.objectStoreNames.contains('types')) {
                            const typeStore = db.createObjectStore('types', { keyPath: 'id', autoIncrement: true });
                            typeStore.createIndex('projectId', 'projectId', { unique: false });
                        }
                    };
                });
            }

            async addProject(project) {
                const transaction = this.db.transaction(['projects'], 'readwrite');
                const store = transaction.objectStore('projects');
                return store.add({
                    ...project,
                    createdAt: new Date().toISOString()
                });
            }

            async updateProject(project) {
                const transaction = this.db.transaction(['projects'], 'readwrite');
                const store = transaction.objectStore('projects');
                return store.put(project);
            }

            async addRecords(records) {
                const transaction = this.db.transaction(['records'], 'readwrite');
                const store = transaction.objectStore('records');
                const promises = records.map(record => store.add(record));
                return Promise.all(promises);
            }

            async markProjectAsImported(projectId) {
                const transaction = this.db.transaction(['projects'], 'readwrite');
                const store = transaction.objectStore('projects');
                const project = await new Promise((resolve, reject) => {
                    const request = store.get(projectId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                
                if (project) {
                    project.hasImported = true;
                    project.importedAt = new Date().toISOString();
                    return store.put(project);
                }
            }

            async deleteProject(id) {
                const transaction = this.db.transaction(['projects', 'records', 'types'], 'readwrite');
                
                // åˆ é™¤é¡¹ç›®
                transaction.objectStore('projects').delete(id);
                
                // åˆ é™¤ç›¸å…³è®°å½•
                const recordStore = transaction.objectStore('records');
                const recordIndex = recordStore.index('projectId');
                const recordRequest = recordIndex.openCursor(IDBKeyRange.only(id));
                recordRequest.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        cursor.delete();
                        cursor.continue();
                    }
                };
                
                // åˆ é™¤ç›¸å…³ç±»å‹
                const typeStore = transaction.objectStore('types');
                const typeIndex = typeStore.index('projectId');
                const typeRequest = typeIndex.openCursor(IDBKeyRange.only(id));
                typeRequest.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        cursor.delete();
                        cursor.continue();
                    }
                };
                
                return transaction.complete;
            }

            async getProjects() {
                const transaction = this.db.transaction(['projects'], 'readonly');
                const store = transaction.objectStore('projects');
                return new Promise((resolve, reject) => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async addRecord(record) {
                const transaction = this.db.transaction(['records'], 'readwrite');
                const store = transaction.objectStore('records');
                return store.add({
                    ...record,
                    createdAt: new Date().toISOString()
                });
            }

            async updateRecord(record) {
                const transaction = this.db.transaction(['records'], 'readwrite');
                const store = transaction.objectStore('records');
                return store.put(record);
            }

            async deleteRecord(id) {
                const transaction = this.db.transaction(['records'], 'readwrite');
                const store = transaction.objectStore('records');
                return store.delete(id);
            }

            async getRecords(projectId) {
                const transaction = this.db.transaction(['records'], 'readonly');
                const store = transaction.objectStore('records');
                const index = store.index('projectId');
                return new Promise((resolve, reject) => {
                    const request = index.getAll(projectId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async addType(type) {
                const transaction = this.db.transaction(['types'], 'readwrite');
                const store = transaction.objectStore('types');
                return store.add(type);
            }

            async deleteType(projectId, typeName) {
                const transaction = this.db.transaction(['types'], 'readwrite');
                const store = transaction.objectStore('types');
                const index = store.index('projectId');
                return new Promise((resolve, reject) => {
                    const request = index.openCursor(IDBKeyRange.only(projectId));
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            if (cursor.value.name === typeName) {
                                cursor.delete();
                                resolve();
                            } else {
                                cursor.continue();
                            }
                        } else {
                            resolve();
                        }
                    };
                    request.onerror = () => reject(request.error);
                });
            }

            async getTypes(projectId) {
                const transaction = this.db.transaction(['types'], 'readonly');
                const store = transaction.objectStore('types');
                const index = store.index('projectId');
                return new Promise((resolve, reject) => {
                    const request = index.getAll(projectId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }
        }

        createApp({
            data() {
                return {
                    db: new AccountingDB(),
                    projects: [],
                    currentProject: null,
                    currentProjectData: null,
                    currentProjectTypes: [],
                    records: [],
                    filteredData: [],
                    currentPage: 1,
                    pageSize: 20,
                    filters: {
                        type: '',
                        category: '',
                        dateRange: null,
                        keyword: ''
                    },
                    showProjectDialog: false,
                    showRecordDialog: false,
                    showTypeDialog: false,
                    showImportDialog: false,
                    editingProject: null,
                    editingRecord: null,
                    projectForm: {
                        name: '',
                        description: ''
                    },
                    recordForm: {
                        type: '',
                        category: 'expense',
                        amount: 0,
                        date: dayjs().format('YYYY-MM-DD'),
                        remark: '',
                        ticketLocation: ''
                    },
                    newTypeName: '',
                    trendChartInstance: null,
                    categoryChartInstance: null,
                    importPreviewData: [],
                    importLoading: false,
                    currentUploadFile: null,
                    totalImportCount: 0
                };
            },
            computed: {
                totalIncome() {
                    return this.filteredData
                        .filter(item => item.category === 'income')
                        .reduce((sum, item) => sum + item.amount, 0);
                },
                totalExpense() {
                    return this.filteredData
                        .filter(item => item.category === 'expense')
                        .reduce((sum, item) => sum + item.amount, 0);
                },
                balance() {
                    return this.totalIncome - this.totalExpense;
                },
                totalRecords() {
                    return this.filteredData.length;
                },
                incomeCount() {
                    return this.filteredData.filter(item => item.category === 'income').length;
                },
                expenseCount() {
                    return this.filteredData.filter(item => item.category === 'expense').length;
                },
                paginatedData() {
                    const start = (this.currentPage - 1) * this.pageSize;
                    const end = start + this.pageSize;
                    return this.filteredData.slice(start, end);
                },
                canImport() {
                    return this.currentProjectData && 
                           this.records.length === 0 && 
                           !this.currentProjectData.hasImported;
                }
            },
            async mounted() {
                await this.initDB();
                await this.loadProjects();
            },
            methods: {
                async initDB() {
                    try {
                        await this.db.init();
                        console.log('æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ');
                    } catch (error) {
                        console.error('æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error);
                        ElMessage.error('æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥');
                    }
                },
                async loadProjects() {
                    try {
                        this.projects = await this.db.getProjects();
                        if (this.projects.length > 0 && !this.currentProject) {
                            this.currentProject = this.projects[0].id;
                            await this.onProjectChange();
                        }
                    } catch (error) {
                        console.error('åŠ è½½é¡¹ç›®å¤±è´¥:', error);
                        ElMessage.error('åŠ è½½é¡¹ç›®å¤±è´¥');
                    }
                },
                async onProjectChange() {
                    if (!this.currentProject) {
                        this.currentProjectData = null;
                        return;
                    }
                    
                    this.currentProjectData = this.projects.find(p => p.id === this.currentProject);
                    await this.loadRecords();
                    await this.loadTypes();
                    this.resetFilters();
                },
                async loadRecords() {
                    try {
                        this.records = await this.db.getRecords(this.currentProject);
                        // æŒ‰æ—¥æœŸé™åºæ’åºï¼ˆæ–°æ—¥æœŸåœ¨å‰ï¼‰
                        this.records.sort((a, b) => new Date(b.date) - new Date(a.date));
                        this.filteredData = [...this.records];
                        // ä½¿ç”¨å»¶è¿Ÿç¡®ä¿DOMå®Œå…¨æ¸²æŸ“
                        setTimeout(() => {
                            this.generateCharts();
                        }, 100);
                    } catch (error) {
                        console.error('åŠ è½½è®°å½•å¤±è´¥:', error);
                        ElMessage.error('åŠ è½½è®°å½•å¤±è´¥');
                    }
                },
                async loadTypes() {
                    try {
                        const types = await this.db.getTypes(this.currentProject);
                        this.currentProjectTypes = types.map(t => t.name);
                        
                        // å¦‚æœæ²¡æœ‰ç±»å‹ï¼Œæ·»åŠ é»˜è®¤ç±»å‹
                        if (this.currentProjectTypes.length === 0) {
                            const defaultTypes = ['é›¶æ˜Ÿæ‚é¡¹', 'ç Œç –å·¥èµ„', 'äºŒæ„å·¥èµ„', 'åœŸæ–¹æœºæ¢°', 'å¡”åŠç§Ÿèµ', 'é’¢ç®¡ç§Ÿèµ', 'ç ¼å·¥èµ„', 'é’¢ç­‹å·¥èµ„'];
                            for (const typeName of defaultTypes) {
                                await this.db.addType({
                                    projectId: this.currentProject,
                                    name: typeName
                                });
                            }
                            await this.loadTypes();
                        }
                    } catch (error) {
                        console.error('åŠ è½½ç±»å‹å¤±è´¥:', error);
                        ElMessage.error('åŠ è½½ç±»å‹å¤±è´¥');
                    }
                },
                async saveProject() {
                    if (!this.projectForm.name.trim()) {
                        ElMessage.warning('è¯·è¾“å…¥é¡¹ç›®åç§°');
                        return;
                    }
                    
                    try {
                        if (this.editingProject) {
                            await this.db.updateProject({
                                ...this.editingProject,
                                ...this.projectForm
                            });
                            ElMessage.success('é¡¹ç›®æ›´æ–°æˆåŠŸ');
                        } else {
                            await this.db.addProject(this.projectForm);
                            ElMessage.success('é¡¹ç›®åˆ›å»ºæˆåŠŸ');
                        }
                        
                        this.showProjectDialog = false;
                        this.editingProject = null;
                        this.projectForm = { name: '', description: '' };
                        await this.loadProjects();
                    } catch (error) {
                        console.error('ä¿å­˜é¡¹ç›®å¤±è´¥:', error);
                        ElMessage.error('ä¿å­˜é¡¹ç›®å¤±è´¥');
                    }
                },
                editCurrentProject() {
                    if (!this.currentProjectData) return;
                    
                    this.editingProject = this.currentProjectData;
                    this.projectForm = {
                        name: this.currentProjectData.name,
                        description: this.currentProjectData.description || ''
                    };
                    this.showProjectDialog = true;
                },
                async deleteCurrentProject() {
                    if (!this.currentProject) return;
                    
                    try {
                        await ElMessageBox.confirm('ç¡®å®šåˆ é™¤å½“å‰é¡¹ç›®å—ï¼Ÿè¿™å°†åˆ é™¤é¡¹ç›®ä¸‹çš„æ‰€æœ‰è®°å½•ï¼', 'è­¦å‘Š', {
                            confirmButtonText: 'ç¡®å®š',
                            cancelButtonText: 'å–æ¶ˆ',
                            type: 'warning'
                        });
                        
                        await this.db.deleteProject(this.currentProject);
                        ElMessage.success('é¡¹ç›®åˆ é™¤æˆåŠŸ');
                        
                        this.currentProject = null;
                        this.currentProjectData = null;
                        await this.loadProjects();
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('åˆ é™¤é¡¹ç›®å¤±è´¥:', error);
                            ElMessage.error('åˆ é™¤é¡¹ç›®å¤±è´¥');
                        }
                    }
                },
                async saveRecord() {
                    if (!this.recordForm.type || !this.recordForm.amount || !this.recordForm.date) {
                        ElMessage.warning('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯');
                        return;
                    }
                    
                    try {
                        const recordData = {
                            ...this.recordForm,
                            projectId: this.currentProject
                        };
                        
                        if (this.editingRecord) {
                            // ç¼–è¾‘è®°å½•æ—¶éœ€è¦ç¡®è®¤
                            const confirmText = `ç¡®è®¤ä¿®æ”¹è®°å½•å—ï¼Ÿ`;
                            
                            await ElMessageBox.confirm(confirmText, 'ç¡®è®¤ä¿®æ”¹è®°å½•', {
                                confirmButtonText: 'ç¡®è®¤ä¿®æ”¹',
                                cancelButtonText: 'å–æ¶ˆ',
                                type: 'info',
                                dangerouslyUseHTMLString: false
                            });
                            
                            await this.db.updateRecord({
                                ...this.editingRecord,
                                ...recordData
                            });
                            ElMessage.success('è®°å½•æ›´æ–°æˆåŠŸ');
                        } else {
                            // æ–°å¢è®°å½•ç›´æ¥ä¿å­˜
                            await this.db.addRecord(recordData);
                            ElMessage.success('è®°å½•æ·»åŠ æˆåŠŸ');
                        }
                        
                        this.showRecordDialog = false;
                        this.editingRecord = null;
                        this.recordForm = {
                            type: '',
                            category: 'expense',
                            amount: 0,
                            date: dayjs().format('YYYY-MM-DD'),
                            remark: '',
                            ticketLocation: ''
                        };
                        await this.loadRecords();
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('ä¿å­˜è®°å½•å¤±è´¥:', error);
                            ElMessage.error('ä¿å­˜è®°å½•å¤±è´¥');
                        }
                    }
                },
                editRecord(record) {
                    this.editingRecord = record;
                    this.recordForm = {
                        type: record.type,
                        category: record.category,
                        amount: record.amount,
                        date: record.date,
                        remark: record.remark || '',
                        ticketLocation: record.ticketLocation || ''
                    };
                    this.showRecordDialog = true;
                },
                async deleteRecord(id) {
                    try {
                        await ElMessageBox.confirm('ç¡®å®šåˆ é™¤è¿™æ¡è®°å½•å—ï¼Ÿ', 'ç¡®è®¤', {
                            confirmButtonText: 'ç¡®å®š',
                            cancelButtonText: 'å–æ¶ˆ',
                            type: 'warning'
                        });
                        
                        await this.db.deleteRecord(id);
                        ElMessage.success('è®°å½•åˆ é™¤æˆåŠŸ');
                        await this.loadRecords();
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('åˆ é™¤è®°å½•å¤±è´¥:', error);
                            ElMessage.error('åˆ é™¤è®°å½•å¤±è´¥');
                        }
                    }
                },
                async addType() {
                    if (!this.newTypeName.trim()) {
                        ElMessage.warning('è¯·è¾“å…¥ç±»å‹åç§°');
                        return;
                    }
                    
                    if (this.currentProjectTypes.includes(this.newTypeName)) {
                        ElMessage.warning('ç±»å‹å·²å­˜åœ¨');
                        return;
                    }
                    
                    try {
                        await this.db.addType({
                            projectId: this.currentProject,
                            name: this.newTypeName
                        });
                        
                        this.newTypeName = '';
                        await this.loadTypes();
                        ElMessage.success('ç±»å‹æ·»åŠ æˆåŠŸ');
                    } catch (error) {
                        console.error('æ·»åŠ ç±»å‹å¤±è´¥:', error);
                        ElMessage.error('æ·»åŠ ç±»å‹å¤±è´¥');
                    }
                },
                async removeType(typeName) {
                    try {
                        // æ£€æŸ¥æ˜¯å¦æœ‰è®°å½•ä½¿ç”¨äº†æ­¤ç±»å‹
                        const recordsUsingType = this.records.filter(record => record.type === typeName);
                        
                        if (recordsUsingType.length > 0) {
                            ElMessage.warning(`æ— æ³•åˆ é™¤ç±»å‹"${typeName}"ï¼Œå½“å‰æœ‰ ${recordsUsingType.length} æ¡è®°å½•æ­£åœ¨ä½¿ç”¨æ­¤ç±»å‹ã€‚è¯·å…ˆåˆ é™¤æˆ–ä¿®æ”¹ç›¸å…³è®°å½•ã€‚`);
                            return;
                        }
                        
                        // ç¡®è®¤åˆ é™¤
                        await ElMessageBox.confirm(`ç¡®å®šåˆ é™¤ç±»å‹"${typeName}"å—ï¼Ÿ`, 'ç¡®è®¤åˆ é™¤', {
                            confirmButtonText: 'ç¡®å®š',
                            cancelButtonText: 'å–æ¶ˆ',
                            type: 'warning'
                        });
                        
                        await this.db.deleteType(this.currentProject, typeName);
                        await this.loadTypes();
                        ElMessage.success('ç±»å‹åˆ é™¤æˆåŠŸ');
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('åˆ é™¤ç±»å‹å¤±è´¥:', error);
                            ElMessage.error('åˆ é™¤ç±»å‹å¤±è´¥');
                        }
                    }
                },
                applyFilters() {
                    this.filteredData = this.records.filter(item => {
                        // ç±»å‹ç­›é€‰
                        if (this.filters.type && item.type !== this.filters.type) {
                            return false;
                        }
                        
                        // ç±»åˆ«ç­›é€‰
                        if (this.filters.category && item.category !== this.filters.category) {
                            return false;
                        }
                        
                        // æ—¥æœŸèŒƒå›´ç­›é€‰
                        if (this.filters.dateRange && this.filters.dateRange.length === 2) {
                            if (item.date < this.filters.dateRange[0] || item.date > this.filters.dateRange[1]) {
                                return false;
                            }
                        }
                        
                        // å…³é”®è¯æœç´¢
                        if (this.filters.keyword) {
                            const keyword = this.filters.keyword.toLowerCase();
                            const remark = (item.remark || '').toLowerCase();
                            if (!remark.includes(keyword)) {
                                return false;
                            }
                        }
                        
                        return true;
                    });
                    
                    // ç­›é€‰åä¹ŸæŒ‰æ—¥æœŸé™åºæ’åº
                    this.filteredData.sort((a, b) => new Date(b.date) - new Date(a.date));
                    
                    this.currentPage = 1;
                    // ä½¿ç”¨å»¶è¿Ÿç¡®ä¿DOMå®Œå…¨æ¸²æŸ“
                    setTimeout(() => {
                        this.generateCharts();
                    }, 100);
                },
                resetFilters() {
                    this.filters = {
                        type: '',
                        category: '',
                        dateRange: null,
                        keyword: ''
                    };
                    this.filteredData = [...this.records];
                    // é‡ç½®ç­›é€‰åä¹ŸæŒ‰æ—¥æœŸé™åºæ’åº
                    this.filteredData.sort((a, b) => new Date(b.date) - new Date(a.date));
                    this.currentPage = 1;
                    
                    // å…ˆé”€æ¯ç°æœ‰å›¾è¡¨ï¼Œå†é‡æ–°åˆ›å»º
                    if (this.trendChartInstance) {
                        try {
                            this.trendChartInstance.destroy();
                        } catch (error) {
                            console.warn('é‡ç½®æ—¶é”€æ¯è¶‹åŠ¿å›¾è¡¨å¤±è´¥:', error);
                        }
                        this.trendChartInstance = null;
                    }
                    
                    if (this.categoryChartInstance) {
                        try {
                            this.categoryChartInstance.destroy();
                        } catch (error) {
                            console.warn('é‡ç½®æ—¶é”€æ¯åˆ†ç±»å›¾è¡¨å¤±è´¥:', error);
                        }
                        this.categoryChartInstance = null;
                    }
                    
                    // ä½¿ç”¨å»¶è¿Ÿç¡®ä¿DOMå®Œå…¨æ¸²æŸ“å’Œå›¾è¡¨å®Œå…¨é”€æ¯
                    setTimeout(() => {
                        this.generateCharts();
                    }, 150);
                },
                exportData() {
                    if (this.filteredData.length === 0) {
                        ElMessage.warning('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
                        return;
                    }
                    
                    // åˆ†ç¦»æ”¶å…¥å’Œæ”¯å‡ºæ•°æ®
                    const incomeData = this.filteredData
                        .filter(item => item.category === 'income')
                        .map(item => ({
                            'æ—¥æœŸ': item.date,
                            'ç±»å‹': item.type,
                            'é‡‘é¢': item.amount,
                            'å¤‡æ³¨': item.remark || '',
                            'ç¥¨æ®ä½ç½®': item.ticketLocation || ''
                        }));
                    
                    const expenseData = this.filteredData
                        .filter(item => item.category === 'expense')
                        .map(item => ({
                            'æ—¥æœŸ': item.date,
                            'ç±»å‹': item.type,
                            'é‡‘é¢': item.amount,
                            'å¤‡æ³¨': item.remark || '',
                            'ç¥¨æ®ä½ç½®': item.ticketLocation || ''
                        }));
                    
                    // åˆ›å»ºå·¥ä½œç°¿
                    const workbook = XLSX.utils.book_new();
                    
                    // åˆ›å»ºæ”¶å…¥å·¥ä½œè¡¨
                    if (incomeData.length > 0) {
                        const incomeWorksheet = XLSX.utils.json_to_sheet(incomeData);
                        XLSX.utils.book_append_sheet(workbook, incomeWorksheet, 'æ”¶å…¥è®°å½•');
                    }
                    
                    // åˆ›å»ºæ”¯å‡ºå·¥ä½œè¡¨
                    if (expenseData.length > 0) {
                        const expenseWorksheet = XLSX.utils.json_to_sheet(expenseData);
                        XLSX.utils.book_append_sheet(workbook, expenseWorksheet, 'æ”¯å‡ºè®°å½•');
                    }
                    
                    // å¦‚æœæ²¡æœ‰ä»»ä½•æ•°æ®
                    if (incomeData.length === 0 && expenseData.length === 0) {
                        ElMessage.warning('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
                        return;
                    }
                    
                    const fileName = `${this.currentProjectData.name}_è®°è´¦æ•°æ®_${dayjs().format('YYYY-MM-DD')}.xlsx`;
                    XLSX.writeFile(workbook, fileName);
                    
                    let message = 'æ•°æ®å¯¼å‡ºæˆåŠŸï¼';
                    if (incomeData.length > 0 && expenseData.length > 0) {
                        message += `ï¼ˆæ”¶å…¥è®°å½•${incomeData.length}æ¡ï¼Œæ”¯å‡ºè®°å½•${expenseData.length}æ¡ï¼‰`;
                    } else if (incomeData.length > 0) {
                        message += `ï¼ˆæ”¶å…¥è®°å½•${incomeData.length}æ¡ï¼‰`;
                    } else {
                        message += `ï¼ˆæ”¯å‡ºè®°å½•${expenseData.length}æ¡ï¼‰`;
                    }
                    
                    ElMessage.success(message);
                },
                formatMoney(amount) {
                    return new Intl.NumberFormat('zh-CN', {
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2
                    }).format(amount);
                },
                formatDate(date) {
                    return dayjs(date).format('YYYY-MM-DD');
                },
                getTypeTagColor(type) {
                    const colors = ['', 'success', 'info', 'warning', 'danger'];
                    const hash = type.split('').reduce((a, b) => {
                        a = ((a << 5) - a) + b.charCodeAt(0);
                        return a & a;
                    }, 0);
                    return colors[Math.abs(hash) % colors.length];
                },
                generateCharts() {
                    // ç¡®ä¿canvaså…ƒç´ å­˜åœ¨ä¸”å¯è§
                    if (!this.$refs.trendChart || !this.$refs.categoryChart) {
                        return;
                    }
                    
                    // ç¡®ä¿ä¹‹å‰çš„å›¾è¡¨å®ä¾‹å®Œå…¨æ¸…ç†
                    if (this.trendChartInstance) {
                        try {
                            this.trendChartInstance.destroy();
                        } catch (error) {
                            console.warn('æ¸…ç†è¶‹åŠ¿å›¾è¡¨å®ä¾‹å¤±è´¥:', error);
                        }
                        this.trendChartInstance = null;
                    }
                    
                    if (this.categoryChartInstance) {
                        try {
                            this.categoryChartInstance.destroy();
                        } catch (error) {
                            console.warn('æ¸…ç†åˆ†ç±»å›¾è¡¨å®ä¾‹å¤±è´¥:', error);
                        }
                        this.categoryChartInstance = null;
                    }
                    
                    // å°å»¶è¿Ÿç¡®ä¿é”€æ¯å®Œæˆ
                    setTimeout(() => {
                        this.generateTrendChart();
                        this.generateCategoryChart();
                    }, 50);
                },
                generateTrendChart() {
                    if (!this.$refs.trendChart || this.filteredData.length === 0) return;
                    
                    // å®‰å…¨é”€æ¯ä¹‹å‰çš„å›¾è¡¨å®ä¾‹
                    if (this.trendChartInstance) {
                        try {
                            this.trendChartInstance.destroy();
                        } catch (error) {
                            console.warn('é”€æ¯è¶‹åŠ¿å›¾è¡¨å¤±è´¥:', error);
                        }
                        this.trendChartInstance = null;
                    }
                    
                    const ctx = this.$refs.trendChart.getContext('2d');
                    
                    // æŒ‰æœˆç»Ÿè®¡æ•°æ®
                    const monthlyData = {};
                    this.filteredData.forEach(item => {
                        const month = dayjs(item.date).format('YYYY-MM');
                        if (!monthlyData[month]) {
                            monthlyData[month] = { income: 0, expense: 0 };
                        }
                        if (item.category === 'income') {
                            monthlyData[month].income += item.amount;
                        } else {
                            monthlyData[month].expense += item.amount;
                        }
                    });
                    
                    const labels = Object.keys(monthlyData).sort();
                    const incomeData = labels.map(month => monthlyData[month].income);
                    const expenseData = labels.map(month => monthlyData[month].expense);
                    
                    this.trendChartInstance = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'æ”¶å…¥',
                                data: incomeData,
                                borderColor: '#27AE60',
                                backgroundColor: 'rgba(39, 174, 96, 0.1)',
                                tension: 0.4,
                                fill: true
                            }, {
                                label: 'æ”¯å‡º',
                                data: expenseData,
                                borderColor: '#E74C3C',
                                backgroundColor: 'rgba(231, 76, 60, 0.1)',
                                tension: 0.4,
                                fill: true
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top'
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                },
                generateCategoryChart() {
                    if (!this.$refs.categoryChart || this.filteredData.length === 0) return;
                    
                    // å®‰å…¨é”€æ¯ä¹‹å‰çš„å›¾è¡¨å®ä¾‹
                    if (this.categoryChartInstance) {
                        try {
                            this.categoryChartInstance.destroy();
                        } catch (error) {
                            console.warn('é”€æ¯åˆ†ç±»å›¾è¡¨å¤±è´¥:', error);
                        }
                        this.categoryChartInstance = null;
                    }
                    
                    const ctx = this.$refs.categoryChart.getContext('2d');
                    
                    // ç»Ÿè®¡æ”¯å‡ºç±»å‹
                    const typeData = {};
                    this.filteredData.filter(item => item.category === 'expense').forEach(item => {
                        typeData[item.type] = (typeData[item.type] || 0) + item.amount;
                    });
                    
                    const labels = Object.keys(typeData);
                    const data = Object.values(typeData);
                    const colors = [
                        '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                        '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
                    ];
                    
                    if (labels.length === 0) {
                        ctx.font = '16px Arial';
                        ctx.fillStyle = '#999';
                        ctx.textAlign = 'center';
                        ctx.fillText('æš‚æ— æ”¯å‡ºæ•°æ®', ctx.canvas.width / 2, ctx.canvas.height / 2);
                        return;
                    }
                    
                    this.categoryChartInstance = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: labels,
                            datasets: [{
                                data: data,
                                backgroundColor: colors.slice(0, labels.length),
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                },
                async handleFileChange(file) {
                    if (file) {
                        this.importPreviewData = []; // æ¸…ç©ºé¢„è§ˆæ•°æ®
                        this.importLoading = true;
                        this.currentUploadFile = file; // ä¿å­˜æ–‡ä»¶å¼•ç”¨
                        try {
                            const workbook = XLSX.read(await file.raw.arrayBuffer(), { type: 'array' });
                            
                            // æ£€æŸ¥æ˜¯å¦åŒ…å«"æ”¶å…¥è®°å½•"å’Œ"æ”¯å‡ºè®°å½•"å·¥ä½œè¡¨
                            const incomeSheet = workbook.Sheets['æ”¶å…¥è®°å½•'];
                            const expenseSheet = workbook.Sheets['æ”¯å‡ºè®°å½•'];

                            if (!incomeSheet && !expenseSheet) {
                                ElMessage.error('Excelæ–‡ä»¶ä¸­æœªæ‰¾åˆ°"æ”¶å…¥è®°å½•"æˆ–"æ”¯å‡ºè®°å½•"å·¥ä½œè¡¨ï¼');
                                this.importLoading = false;
                                this.totalImportCount = 0;
                                return;
                            }

                            // æ£€æŸ¥é¡¹ç›®æ˜¯å¦å·²æœ‰è®°å½•
                            const existingRecords = await this.db.getRecords(this.currentProject);
                            if (existingRecords.length > 0) {
                                ElMessage.warning('å½“å‰é¡¹ç›®å·²æœ‰è®°å½•ï¼Œæ— æ³•å¯¼å…¥ï¼è¯·å…ˆæ¸…ç©ºé¡¹ç›®è®°å½•ã€‚');
                                this.importLoading = false;
                                this.totalImportCount = 0;
                                return;
                            }

                            // æ£€æŸ¥é¡¹ç›®æ˜¯å¦å·²å¯¼å…¥è¿‡
                            if (this.currentProjectData.hasImported) {
                                ElMessage.warning('æ­¤é¡¹ç›®å·²ç»å¯¼å…¥è¿‡æ•°æ®ï¼Œä¸èƒ½é‡å¤å¯¼å…¥ï¼');
                                this.importLoading = false;
                                this.totalImportCount = 0;
                                return;
                            }

                            // è§£ææ”¶å…¥å’Œæ”¯å‡ºæ•°æ®
                            let allData = [];
                            
                            if (incomeSheet) {
                                const incomeData = XLSX.utils.sheet_to_json(incomeSheet);
                                const processedIncomeData = incomeData.map(item => ({
                                    date: item['æ—¥æœŸ'],
                                    type: item['ç±»å‹'],
                                    category: 'income',
                                    amount: parseFloat(item['é‡‘é¢']),
                                    remark: item['å¤‡æ³¨'] || '',
                                    ticketLocation: item['ç¥¨æ®ä½ç½®'] || ''
                                }));
                                allData = allData.concat(processedIncomeData);
                            }
                            
                            if (expenseSheet) {
                                const expenseData = XLSX.utils.sheet_to_json(expenseSheet);
                                const processedExpenseData = expenseData.map(item => ({
                                    date: item['æ—¥æœŸ'],
                                    type: item['ç±»å‹'], 
                                    category: 'expense',
                                    amount: parseFloat(item['é‡‘é¢']),
                                    remark: item['å¤‡æ³¨'] || '',
                                    ticketLocation: item['ç¥¨æ®ä½ç½®'] || ''
                                }));
                                allData = allData.concat(processedExpenseData);
                            }

                            // éªŒè¯æ•°æ®æ ¼å¼
                            const validData = allData.filter(item => {
                                return item.date && item.type && item.amount && !isNaN(item.amount);
                            });

                            if (validData.length === 0) {
                                ElMessage.error('æœªæ‰¾åˆ°æœ‰æ•ˆçš„è®°å½•æ•°æ®ï¼');
                                this.importLoading = false;
                                this.totalImportCount = 0;
                                return;
                            }

                            // é¢„è§ˆæ•°æ®
                            this.importPreviewData = validData.slice(0, 10); // é¢„è§ˆå‰10æ¡è®°å½•
                            this.totalImportCount = validData.length; // ä¿å­˜æ€»è®°å½•æ•°
                            ElMessage.success(`æ–‡ä»¶è§£ææˆåŠŸï¼Œæ‰¾åˆ° ${validData.length} æ¡æœ‰æ•ˆè®°å½•ã€‚`);
                        } catch (error) {
                            console.error('å¯¼å…¥Excelå¤±è´¥:', error);
                            ElMessage.error('å¯¼å…¥Excelå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼æˆ–å†…å®¹ï¼');
                            this.totalImportCount = 0;
                        } finally {
                            this.importLoading = false;
                        }
                    }
                },
                handleFileRemove() {
                    this.importPreviewData = [];
                    this.currentUploadFile = null;
                    this.totalImportCount = 0;
                    ElMessage.info('å·²ç§»é™¤Excelæ–‡ä»¶');
                },
                cancelImport() {
                    this.showImportDialog = false;
                    this.importPreviewData = [];
                    this.currentUploadFile = null;
                    this.totalImportCount = 0;
                    if (this.$refs.uploadRef) {
                        this.$refs.uploadRef.clearFiles();
                    }
                },
                async confirmImport() {
                    if (this.importPreviewData.length === 0) {
                        ElMessage.warning('è¯·å…ˆé€‰æ‹©æ–‡ä»¶å¹¶é¢„è§ˆæ•°æ®ï¼');
                        return;
                    }

                    try {
                        await ElMessageBox.confirm('ç¡®å®šè¦å¯¼å…¥è¿™äº›æ•°æ®å—ï¼Ÿå¯¼å…¥åæ­¤é¡¹ç›®å°†ä¸èƒ½å†æ¬¡å¯¼å…¥ã€‚', 'ç¡®è®¤å¯¼å…¥', {
                            confirmButtonText: 'ç¡®å®šå¯¼å…¥',
                            cancelButtonText: 'å–æ¶ˆ',
                            type: 'warning'
                        });

                        this.importLoading = true;
                        if (!this.currentUploadFile) {
                            ElMessage.error('è¯·å…ˆé€‰æ‹©æ–‡ä»¶ï¼');
                            this.importLoading = false;
                            return;
                        }

                        const workbook = XLSX.read(await this.currentUploadFile.raw.arrayBuffer(), { type: 'array' });
                        
                        // æ£€æŸ¥æ˜¯å¦åŒ…å«"æ”¶å…¥è®°å½•"å’Œ"æ”¯å‡ºè®°å½•"å·¥ä½œè¡¨
                        const incomeSheet = workbook.Sheets['æ”¶å…¥è®°å½•'];
                        const expenseSheet = workbook.Sheets['æ”¯å‡ºè®°å½•'];

                        if (!incomeSheet && !expenseSheet) {
                            ElMessage.error('Excelæ–‡ä»¶ä¸­æœªæ‰¾åˆ°"æ”¶å…¥è®°å½•"æˆ–"æ”¯å‡ºè®°å½•"å·¥ä½œè¡¨ï¼');
                            this.importLoading = false;
                            return;
                        }

                        // å†æ¬¡æ£€æŸ¥é¡¹ç›®çŠ¶æ€
                        const existingRecords = await this.db.getRecords(this.currentProject);
                        if (existingRecords.length > 0) {
                            ElMessage.warning('å½“å‰é¡¹ç›®å·²æœ‰è®°å½•ï¼Œæ— æ³•å¯¼å…¥ï¼');
                            this.importLoading = false;
                            return;
                        }

                        if (this.currentProjectData.hasImported) {
                            ElMessage.warning('æ­¤é¡¹ç›®å·²ç»å¯¼å…¥è¿‡æ•°æ®ï¼Œä¸èƒ½é‡å¤å¯¼å…¥ï¼');
                            this.importLoading = false;
                            return;
                        }

                        // è§£æå¹¶å¤„ç†æ•°æ®
                        let allData = [];
                        let typeSet = new Set();

                        if (incomeSheet) {
                            const incomeData = XLSX.utils.sheet_to_json(incomeSheet);
                            const processedIncomeData = incomeData.map(item => ({
                                date: item['æ—¥æœŸ'],
                                type: item['ç±»å‹'],
                                category: 'income',
                                amount: parseFloat(item['é‡‘é¢']),
                                remark: item['å¤‡æ³¨'] || '',
                                ticketLocation: item['ç¥¨æ®ä½ç½®'] || '',
                                projectId: this.currentProject,
                                createdAt: new Date().toISOString()
                            }));
                            allData = allData.concat(processedIncomeData);
                            processedIncomeData.forEach(item => typeSet.add(item.type));
                        }
                        
                        if (expenseSheet) {
                            const expenseData = XLSX.utils.sheet_to_json(expenseSheet);
                            const processedExpenseData = expenseData.map(item => ({
                                date: item['æ—¥æœŸ'],
                                type: item['ç±»å‹'], 
                                category: 'expense',
                                amount: parseFloat(item['é‡‘é¢']),
                                remark: item['å¤‡æ³¨'] || '',
                                ticketLocation: item['ç¥¨æ®ä½ç½®'] || '',
                                projectId: this.currentProject,
                                createdAt: new Date().toISOString()
                            }));
                            allData = allData.concat(processedExpenseData);
                            processedExpenseData.forEach(item => typeSet.add(item.type));
                        }

                        // éªŒè¯æ•°æ®æ ¼å¼
                        const validData = allData.filter(item => {
                            return item.date && item.type && item.amount && !isNaN(item.amount);
                        });

                        if (validData.length === 0) {
                            ElMessage.error('æœªæ‰¾åˆ°æœ‰æ•ˆçš„è®°å½•æ•°æ®ï¼');
                            this.importLoading = false;
                            return;
                        }

                        // æ·»åŠ æ–°çš„ç±»å‹åˆ°é¡¹ç›®ä¸­
                        for (const typeName of typeSet) {
                            if (!this.currentProjectTypes.includes(typeName)) {
                                await this.db.addType({
                                    projectId: this.currentProject,
                                    name: typeName
                                });
                            }
                        }

                        // æ‰¹é‡æ·»åŠ è®°å½•
                        await this.db.addRecords(validData);
                        
                        // æ ‡è®°é¡¹ç›®ä¸ºå·²å¯¼å…¥
                        await this.db.markProjectAsImported(this.currentProject);
                        
                        ElMessage.success(`æˆåŠŸå¯¼å…¥ ${validData.length} æ¡è®°å½•ï¼`);
                        this.showImportDialog = false;
                        this.importPreviewData = [];
                        this.currentUploadFile = null;
                        this.totalImportCount = 0;
                        if (this.$refs.uploadRef) {
                            this.$refs.uploadRef.clearFiles();
                        }
                        
                        // é‡æ–°åŠ è½½é¡¹ç›®å’Œè®°å½•æ•°æ®
                        await this.loadProjects();
                        await this.onProjectChange();
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('å¯¼å…¥Excelå¤±è´¥:', error);
                            ElMessage.error('å¯¼å…¥Excelå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼æˆ–å†…å®¹ï¼');
                        }
                    } finally {
                        this.importLoading = false;
                    }
                }
            }
        }).use(ElementPlus, {
            locale: ElementPlusLocaleZhCn,
        }).mount('#app');
    </script>
</body>
</html> 